// Main change to take note of, using PrintMessage() and PrintMessageLn() instead of print to allow it to switch between bluetooth and serial depending which is enabled with variables (line 178-199)

/* KNOWN BUGS
 Command inputting breaks with some colon errors
 Bluetooth disconnects 11 seconds after a message is sent from terminal, doesnt reset device just disconnects so you can reconnect easily.
*/


#include <Arduino.h>
#include <queue>
#include <vector>

#include <TB6612FNG.h>        //Motor controller library https://github.com/vincasmiliunas/ESP32-Arduino-TB6612FNG/blob/master/examples/TwoMotors/TwoMotors.ino
#include <BluetoothSerial.h>  //ESP32 bluetooth library https://github.com/espressif/arduino-esp32/tree/master/libraries/BluetoothSerial/examples

//Bluetooth Setup debug text from the library
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

#if !defined(CONFIG_BT_SPP_ENABLED)
#error Serial Bluetooth not available or not enabled. It is only available for the ESP32 chip.
#endif

//Creation of the bluetooth object
BluetoothSerial SerialBT;

// Control Variables
int Start = 1;
int LoopDelay = 1;

// defines pins numbers
const int trigPin1 = 4;
const int echoPin1 = 5;
const int trigPin2 = 18;
const int echoPin2 = 19;
// defines variables
long duration;
int distance;

//Ints for storing wall detection
int WallFront;
int WallBack;
int WallLeft;
int WallRight;

int UltrasoundFrontThreshold = 5;
int UltrasoundRightThreshold = 10;
int UltrasoundLeftThreshold = 10;

//Array to store the IR values
int UltrasoundValues[3];

//Motor Setup
#define MotorAPWM 13  //D3
#define MotorA1 14    //D4
#define MotorA2 12    //D5
#define MotorBPWM 33  //D6
#define MotorB1 26    //D7
#define MotorB2 25    //D8
#define STBY 27       //D9

//Creation of motor controller objects for each motor
/*
Tb6612fng motor1(STBY, MotorA1, MotorA2, MotorAPWM);
Tb6612fng motor2(STBY, MotorB1, MotorB2, MotorBPWM);
*/
Tb6612fng motors(STBY, MotorA1, MotorA2, MotorAPWM, MotorB1, MotorB2, MotorBPWM);

//Variables for the rotary encoders
#define LeftOutputA 35
#define LeftOutputB 34
#define RightOutputA 15
#define RightOutputB 2

int LeftCounter = 0;
int LeftState;
int LeftLastState;

int RightCounter = 0;
int RightState;
int RightLastState;

int DistanceTravelled;

//Command Setup
String InputCommand;                //Full command inputted
int CommandIndexA;                  //Position of first colon
int CommandIndexB;                  //Position of second colon
String CurrentCommand;              //First section of the inputted string (before the first colon)
String CommandInputA;               //Second section of the inputted string (between the colons)
String CommandInputB;               //Third section of the inputted strong (after the last colon)
float CommandIntA;                  //Used if the first input is an int
float CommandIntB;                  //Used if the second input is an int
String OutputString = ("INITIAL");  //Used for data output

//Variables to declare which outputs to use. Bluetooth much cleaner than serial due to problems with ledc
int BluetoothEnabled = 1;
int SerialEnabled = 1;
int DebugEnabled = 1;
int VerboseEnabled = 1;

int MovementCounter = 0;
char MovementList[] = {};  //Forwards = A, TurnLeft = B, TurnRight = C, Back = D

#define N 20        // Size of the maze (20x20)
#define INF 999999  // Infinity, representing unvisited cells

// Directions for moving in the maze (up, down, left, right)
int dRow[] = { -1, 1, 0, 0 };  // Row direction for up and down
int dCol[] = { 0, 0, -1, 1 };  // Column direction for left and right

// Maze: 0 for unknown, 1 for free space, 2 for wall, temporoary simulated map, in future fill with 0s as base and fill information as found
int maze[N][N] = {
  { 1, 1, 1, 2, 2, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1 },
  { 1, 1, 1, 2, 0, 1, 0, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 0, 1 },
  { 1, 1, 1, 2, 0, 1, 0, 2, 1, 1, 1, 2, 2, 2, 1, 2, 1, 0, 0, 1 },
  { 1, 1, 1, 2, 0, 1, 0, 0, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1 },
  { 1, 1, 1, 2, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1 },
  { 2, 1, 1, 2, 0, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1 },
  { 2, 2, 1, 2, 0, 1, 0, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 1, 1, 1 },
  { 0, 0, 1, 2, 0, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 0, 0, 2, 1, 1 },
  { 2, 0, 1, 1, 0, 1, 1, 0, 1, 1, 2, 2, 2, 1, 2, 0, 1, 1, 0, 1 },
  { 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 0, 1, 1, 1, 1, 2, 2, 1 },
  { 2, 0, 1, 2, 2, 1, 1, 1, 1, 0, 2, 1, 1, 1, 1, 2, 1, 2, 0, 1 },
  { 1, 0, 1, 2, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 2, 2, 1 },
  { 1, 1, 1, 2, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1 },
  { 2, 1, 2, 2, 0, 1, 2, 0, 1, 2, 2, 2, 0, 0, 1, 0, 1, 1, 1, 2 },
  { 2, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 2, 0, 1 },
  { 1, 1, 1, 1, 2, 2, 2, 1, 0, 1, 1, 2, 1, 0, 0, 1, 1, 0, 1, 2 },
  { 2, 1, 2, 1, 1, 1, 0, 1, 0, 1, 2, 2, 1, 0, 1, 2, 0, 1, 2, 0 },
  { 2, 0, 2, 1, 1, 2, 2, 1, 0, 1, 1, 0, 2, 0, 2, 1, 2, 1, 0, 1 },
  { 2, 1, 0, 0, 2, 0, 0, 1, 2, 2, 1, 0, 1, 0, 0, 1, 0, 1, 1, 2 },
  { 1, 2, 2, 2, 2, 0, 1, 1, 0, 1, 0, 1, 2, 1, 1, 2, 0, 0, 0, 1 }
};


int startRow = 0;
int startCol = 0;  // Starting point (top-left)
int endRow = 19;
int endCol = 19;  // Ending point (bottom-right)

std::vector<std::pair<int, int>> path;

// Structure to represent a cell in the maze
struct Cell {
  int row, col;
  int dist;  // Distance from the start cell
  bool operator>(const Cell& other) const {
    return dist > other.dist;  // Min-heap by distance
  }
};

struct encoder {  //define encoder construct
  const uint8_t PIN;
  uint32_t numberRotation;
  bool triggered;
};

encoder EncoderX = { RightOutputB, 0, false };  //create encoder instance

void IRAM_ATTR EncoderXInterrupt() {
  EncoderX.numberRotation += 1;
  EncoderX.triggered = true;
}

encoder EncoderY = { LeftOutputA, 0, false };  //create encoder instance

void IRAM_ATTR EncoderYInterrupt() {
  EncoderY.numberRotation += 1;
  EncoderY.triggered = true;
}

void setup() {
  pinMode(trigPin1, OUTPUT);  // Sets the trigPin as an Output
  pinMode(echoPin1, INPUT);   // Sets the echoPin as an Input
  pinMode(trigPin2, OUTPUT);  // Sets the trigPin as an Output
  pinMode(echoPin2, INPUT);   // Sets the echoPin as an Input

  pinMode(EncoderX.PIN, INPUT_PULLUP);
  attachInterrupt(EncoderX.PIN, EncoderXInterrupt, FALLING);

  pinMode(EncoderY.PIN, INPUT_PULLUP);
  attachInterrupt(EncoderY.PIN, EncoderYInterrupt, FALLING);




  motors.begin();                //Begins the motor object
  Serial.begin(9600);            //Serial began at a baud rate of 9600, baud rate doesnt matter particularly but must match on the terminal
  SerialBT.begin("MicroMouse");  //Bluetooth device name
  PrintMessageLn("Setup Complete");
  delay(100);
}

void loop() {
  CheckCommand();

  if (EncoderX.triggered) {
    DebugLn("Encoder X has triggered: ", 1);
    DebugLn(String(EncoderX.numberRotation), 1);
    EncoderX.triggered = false;
  }

  if (EncoderY.triggered) {
    DebugLn("Encoder Y has triggered: ", 1);
    DebugLn(String(EncoderY.numberRotation), 1);
    EncoderY.triggered = false;
  }

  delay(100);
}

//CHECKCOMMAND AND READCOMMAND ARE COMPLETELY UNNECESSARY TO THE FUNCTIONALITY OF THE DEVICE, PURELY DEBUG I DONT KNOW HOW IT WORKS AND IM TOO AFRAID TO MESS WITH IT
void CheckCommand() {  //Checks if a command has been sent to either the serial or bluetooth ports, not sure what happens if both are sent at once, please dont test it
  if (Serial.available() != 0) {
    InputCommand = Serial.readString();
    CommandIndexA = InputCommand.indexOf(":");
    if (CommandIndexA == -1) {
      InputCommand = InputCommand + ":000:";
    }
    ReadCommand();
  }
  if (SerialBT.available() != 0) {
    InputCommand = SerialBT.readString();
    CommandIndexA = InputCommand.indexOf(":");
    if (CommandIndexA == -1) {
      InputCommand = InputCommand + ":000:";
    }
    ReadCommand();
  }
}

void ReadCommand() {  //Detects the markers in the code and separates the sections, then decides which function to trigger.
  PrintMessageLn(InputCommand);
  CommandIndexA = InputCommand.indexOf(":");  //Error with detecting commands without any colons at the end
  if (CommandIndexA > -1) {
    CommandIndexB = InputCommand.indexOf(":", (CommandIndexA + 1));
    CurrentCommand = InputCommand.substring(0, CommandIndexA);
  } else {
    CurrentCommand = String(InputCommand);
    CommandIndexB = -1;
  }
  if (CommandIndexA > -1) {  //
    if (CommandIndexB > -1) {
      CommandInputA = InputCommand.substring((CommandIndexA + 1), (CommandIndexB));
      CommandInputB = InputCommand.substring((CommandIndexB + 1));
    } else {
      CommandInputA = InputCommand.substring((CommandIndexA + 1));
      CommandInputB = "0";
    }
  } else {
    CommandInputA = InputCommand.substring((CommandIndexA + 1));
    CommandInputB = "0";
  }
  DebugLn("Current Command:", 0);
  DebugLn(String(CurrentCommand), 0);
  DebugLn("Command Inputs:", 0);
  DebugLn(String(CommandInputA), 0);
  DebugLn(String(CommandInputB), 0);                             //Debug output
  if (CurrentCommand == "Brake" || CurrentCommand == "brake") {  //Code to decide which command has been inputted
    Brake();
  } else if (CurrentCommand == "Forwards" || CurrentCommand == "forwards" || CurrentCommand == "Forward" || CurrentCommand == "forward") {
    CommandIntA = CommandInputA.toFloat();  //Needed as by default the inputs are strings
    CommandIntB = CommandInputB.toFloat();
    DebugLn(String("Command Int:"), 0);
    DebugLn(String(CommandIntA), 0);
    DebugLn(String(CommandIntB), 0);
    Forwards(CommandIntA, CommandIntB);
    //Forwards(0.2, 0.4);
  } else if (CurrentCommand == "Start" || CurrentCommand == "start") {
    Start = 1;
    DebugLn("Starting", 0);
  } else if (CurrentCommand == "Stop" || CurrentCommand == "stop") {
    Start = 0;
    DebugLn("Stopping", 0);
  } else if (CurrentCommand == "EnableDebug" || CurrentCommand == "enabledebug" || CurrentCommand == "Enabledebug" || CurrentCommand == "enableDebug") {
    DebugEnabled = 1;
    Serial.print("Debug Enabled set to ");
    Serial.println(DebugEnabled);
  } else if (CurrentCommand == "DisableDebug" || CurrentCommand == "disabledebug" || CurrentCommand == "Disabledebug" || CurrentCommand == "disableDebug") {
    DebugEnabled = 0;
    Serial.print("Debug Enabled set to ");
    Serial.println(DebugEnabled);
  } else if (CurrentCommand == "EnableVerbose" || CurrentCommand == "enableverbose" || CurrentCommand == "Enableverbose" || CurrentCommand == "enableVerbose") {
    VerboseEnabled = 1;
    Serial.print("Verbose Enabled set to ");
    Serial.println(VerboseEnabled);
  } else if (CurrentCommand == "DisableVerbose" || CurrentCommand == "disableverbose" || CurrentCommand == "Disableverbose" || CurrentCommand == "disableVerbose") {
    VerboseEnabled = 0;
    Serial.print("Verbose Enabled set to ");
    Serial.println(VerboseEnabled);
  } else if (CurrentCommand == "EnableBluetooth" || CurrentCommand == "enablebluetooth" || CurrentCommand == "Enablebluetooth" || CurrentCommand == "enableBluetooth") {
    BluetoothEnabled = 1;
    Debug("Bluetooth Enabled set to: ", 0);
    DebugLn(String(BluetoothEnabled), 0);
  } else if (CurrentCommand == "DisableBluetooth" || CurrentCommand == "disablebluetooth" || CurrentCommand == "Disablebluetooth" || CurrentCommand == "disableBluetooth") {
    BluetoothEnabled = 0;
    Debug("Bluetooth Enabled set to: ", 0);
    DebugLn(String(BluetoothEnabled), 0);
  } else if (CurrentCommand == "EnableSerial" || CurrentCommand == "enableserial" || CurrentCommand == "Enableserial" || CurrentCommand == "enableSerial") {
    SerialEnabled = 1;
    Debug("Serial Enabled set to: ", 0);
    DebugLn(String(SerialEnabled), 0);
  } else if (CurrentCommand == "DisableSerial" || CurrentCommand == "disableserial" || CurrentCommand == "Disableserial" || CurrentCommand == "disableSerial") {
    SerialEnabled = 0;
    Debug("Serial Enabled set to: ", 0);
    DebugLn(String(SerialEnabled), 0);
  } else if (CurrentCommand == "EditLoopDelay" || CurrentCommand == "editloopdelay" || CurrentCommand == "Editloopdelay" || CurrentCommand == "editLoopdelay" || CurrentCommand == "editloopDelay" || CurrentCommand == "EditloopDelay" || CurrentCommand == "editLoopDelay" || CurrentCommand == "EditLoopdelay") {
    CommandIntA = CommandInputA.toInt();
    LoopDelay == CommandIntA;
    Debug("Loop Delay Enabled set to: ", 0);
    DebugLn(String(LoopDelay), 0);
  } else if (CurrentCommand == "ResetEncoder" || CurrentCommand == "resetencoder" || CurrentCommand == "resetEncoder" || CurrentCommand == "Resetencoder") {
    DebugLn("Resetting Encoders", 0);
    ResetEncoder();
  } else if (CurrentCommand == "SolveMaze" || CurrentCommand == "solvemaze" || CurrentCommand == "Solvemaze" || CurrentCommand == "solveMaze") {
    DebugLn("Running Dijkstra's Algorithm", 0);
    SolveMaze();
  } else {
    PrintMessageLn("Unknown Command, did you remember the colons?");
    delay(1000);
  }
}

void PrintMessage(String Message) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (SerialEnabled == 1) {
    Serial.print(Message);
  }
  if (BluetoothEnabled == 1) {  //Doesnt print bluetooth message, only adds to buffer. Will be printed once the PrintMessageLn() command is used. Is due to library problems
    uint8_t buf[Message.length()];
    memcpy(buf, Message.c_str(), Message.length());
    SerialBT.write(buf, Message.length());
  }
}

void PrintMessageLn(String MessageLn) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (SerialEnabled == 1) {
    Serial.println(MessageLn);
  }
  if (BluetoothEnabled == 1) {  //Assembles the message, writes it to buffer then sends buffer
    uint8_t buf[MessageLn.length()];
    memcpy(buf, MessageLn.c_str(), MessageLn.length());
    SerialBT.write(buf, MessageLn.length());
    SerialBT.println();
  }
}

void Debug(String Message, int Verbose) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (DebugEnabled == 1) {
    if (Verbose == 1) {
      if (VerboseEnabled == 1) {
        if (SerialEnabled == 1) {
          Serial.print(Message);
        }
        if (BluetoothEnabled == 1) {  //Assembles the message, writes it to buffer then sends buffer
          uint8_t buf[Message.length()];
          memcpy(buf, Message.c_str(), Message.length());
          SerialBT.write(buf, Message.length());
        }
      }
    } else {
      if (SerialEnabled == 1) {
        Serial.print(Message);
      }
      if (BluetoothEnabled == 1) {  //Doesnt print bluetooth message, only adds to buffer. Will be printed once the PrintMessageLn() command is used. Is due to library problems
        uint8_t buf[Message.length()];
        memcpy(buf, Message.c_str(), Message.length());
        SerialBT.write(buf, Message.length());
      }
    }
  }
}

void DebugLn(String MessageLn, char Verbose) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (DebugEnabled == 1) {
    if (Verbose == 1) {
      if (VerboseEnabled == 1) {
        if (SerialEnabled == 1) {
          Serial.println(MessageLn);
        }
        if (BluetoothEnabled == 1) {  //Assembles the message, writes it to buffer then sends buffer
          uint8_t buf[MessageLn.length()];
          memcpy(buf, MessageLn.c_str(), MessageLn.length());
          SerialBT.write(buf, MessageLn.length());
          SerialBT.println();
        }
      }
    } else {
      if (SerialEnabled == 1) {
        Serial.println(MessageLn);
      }
      if (BluetoothEnabled == 1) {  //Assembles the message, writes it to buffer then sends buffer
        uint8_t buf[MessageLn.length()];
        memcpy(buf, MessageLn.c_str(), MessageLn.length());
        SerialBT.write(buf, MessageLn.length());
        SerialBT.println();
      }
    }
  }
}

void SolveMaze() {
  // Run Dijkstra to solve the maze and get the path
  dijkstra(startRow, startCol, endRow, endCol, path);
  delay(10000);
  Serial.println("Begin Navigation");
  delay(1000);
  // Robot's movement simulation
  int currentIdx = 0;
  while (currentIdx < path.size()) {
    Serial.println("------------------------------------------------------------------------------------------------------------------------------------------");
    move(path, currentIdx);  // Move the robot to the next position in the path
  }
}

void printMaze() {
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      if (maze[i][j] == 2) {
        Serial.print("2");  // Wall
      } else if (maze[i][j] == 1) {
        Serial.print("1");  // Free space
      } else if (maze[i][j] == 0) {
        Serial.print("?");  // Unknown space
      } else if (maze[i][j] == 3) {
        Serial.print("X");
      }
    }
    Serial.println();
  }
  Serial.println();
}

void dijkstra(int startRow, int startCol, int endRow, int endCol, std::vector<std::pair<int, int>>& path) {
  // Priority queue for Dijkstra's algorithm
  std::priority_queue<Cell, std::vector<Cell>, std::greater<Cell>> pq;

  // Distance array, initialized to INF
  int dist[N][N];
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      dist[i][j] = INF;
    }
  }
  dist[startRow][startCol] = 0;  // Starting point

  // Start with the source cell
  pq.push({ startRow, startCol, 0 });

  while (!pq.empty()) {
    Cell curr = pq.top();
    pq.pop();

    int row = curr.row;
    int col = curr.col;

    // If we reach the destination, construct the path
    if (row == endRow && col == endCol) {
      path.push_back({ row, col });
      while (row != startRow || col != startCol) {
        for (int i = 0; i < 4; i++) {
          int newRow = row + dRow[i];
          int newCol = col + dCol[i];
          if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N && dist[newRow][newCol] == dist[row][col] - 1) {
            path.push_back({ newRow, newCol });
            row = newRow;
            col = newCol;
            break;
          }
        }
      }
      std::reverse(path.begin(), path.end());
      return;
    }

    // Explore neighbors (up, down, left, right)
    for (int i = 0; i < 4; i++) {
      int newRow = row + dRow[i];
      int newCol = col + dCol[i];

      // Check if the neighbor is within bounds and is a free space (1)
      if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N && maze[newRow][newCol] != 2) {
        int newDist = dist[row][col] + 1;  // Each move costs 1 step

        // If a shorter path is found, update the distance and push to the queue
        if (newDist < dist[newRow][newCol]) {
          dist[newRow][newCol] = newDist;
          pq.push({ newRow, newCol, newDist });
        }
      }
    }
  }

  // If no path is found
  Serial.println("No path found!");
}

void move(std::vector<std::pair<int, int>>& path, int& currentIdx) {
  if (currentIdx < path.size()) {
    int row = path[currentIdx].first;
    int col = path[currentIdx].second;

    // Update the maze to show robot's position
    maze[row][col] = 3;
    printMaze();
    delay(500);  // Slow down the movement for visibility

    currentIdx++;  // Move to the next step in the path
  }
}

void ResetEncoder() {
  EncoderX.numberRotation = 0;
  EncoderY.numberRotation = 0;
}

void ControlLoop() {  //Loop to control movement
}

void PollSensor() {  //Checks the sensors and adds the values to the IR storage array
  CheckUltrasonicSensor1();
  CheckUltrasonicSensor2();
  //CheckSensor3();
  LeftLastState = digitalRead(LeftOutputA);
  RightLastState = digitalRead(RightOutputA);
}

void MoveSpace(int Distance) {  //Not set up with correct values, needs to be tested, currently just set up to go based on a timer, ideally would use an encoder (code for which is below)
  PrintMessageLn("Moving Fowards");
  Forwards(0.2, -0.195);
  Encoder(Distance);
  Brake(); /*
  MovementList[MovementCounter] = 'A';
  MovementCounter = MovementCounter + 1; */
}

void TurnLeft() {

  PrintMessageLn("Turning Left");
  motors.drive(-0.2, -0.2, 490);
  delay(100);
  Brake();
  MovementList[MovementCounter] = 'B';
  MovementCounter = MovementCounter + 1;
}

void TurnRight() {

  PrintMessageLn("Turning Right");
  motors.drive(0.20, 0.2, 490);
  delay(100);
  Brake();
  MovementList[MovementCounter] = 'C';
  MovementCounter = MovementCounter + 1;
}

void TurnBack() {
  TurnLeft();
  TurnLeft();
}

void Forwards(float x, float y) {  //Command to run both motors based on the input, can be called from terminal (Forwards:x:y)
  PrintMessage("Moving Forwards, Motor speed values set to x = ");
  PrintMessage(String(x));
  PrintMessage(" y = ");
  PrintMessageLn(String(y));
  motors.drive(x, y, 10, false);
}

void Brake() {  //Brake functions for both motors, can be called from terminal (Brake::)
  PrintMessageLn("Braking");
  motors.brake();
}

void CheckUltrasonicSensor1() {
  // Clears the trigPin
  digitalWrite(trigPin1, LOW);
  delayMicroseconds(2);
  // Sets the trigPin on HIGH state for 10 micro seconds
  digitalWrite(trigPin1, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin1, LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin1, HIGH);
  // Calculating the distance
  distance = duration * 0.0343 / 2;
  // Prints the distance on the Serial Monitor
  PrintMessage("Front ");
  PrintMessageLn(String(distance));
  UltrasoundValues[0] = distance;
}

void CheckUltrasonicSensor2() {
  // Clears the trigPin
  digitalWrite(trigPin2, LOW);
  delayMicroseconds(2);
  // Sets the trigPin on HIGH state for 10 micro seconds
  digitalWrite(trigPin2, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin2, LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin2, HIGH);
  // Calculating the distance
  distance = duration * 0.0343 / 2;
  // Prints the distance on the Serial Monitor
  PrintMessage("Right ");
  PrintMessageLn(String(distance));
  UltrasoundValues[1] = distance;
}

void IsWallFront() {  //Checks for wall infront
  if (UltrasoundValues[0] < UltrasoundFrontThreshold) {
    WallFront = 1;
    PrintMessageLn("Wall Found Front");
  } else {
    WallFront = 0;
  }
}

void IsWallLeft() {  //Checks for wall to the left
  if (UltrasoundValues[2] < UltrasoundLeftThreshold) {
    WallLeft = 1;
    PrintMessageLn("Wall Found Left");
  } else {
    WallLeft = 0;
  }
}

void IsWallRight() {  //Checks for wall to the right
  if (UltrasoundValues[1] < UltrasoundRightThreshold) {
    WallRight = 1;
  } else {
    WallRight = 0;
  }
}

void Encoder(int TargetDistance) {  //DOESNT WORK YET
  delay(TargetDistance);
}
