// Main change to take note of, using PrintMessage() and PrintMessageLn() instead of print to allow it to switch between bluetooth and serial depending which is enabled with variables (line 178-199)

/* KNOWN BUGS
 Command inputting breaks with some colon errors
 Bluetooth disconnects 11 seconds after a message is sent from terminal, doesnt reset device just disconnects so you can reconnect easily.
*/

#include <TB6612FNG.h>        //Motor controller library https://github.com/vincasmiliunas/ESP32-Arduino-TB6612FNG/blob/master/examples/TwoMotors/TwoMotors.ino
#include <BluetoothSerial.h>  //ESP32 bluetooth library https://github.com/espressif/arduino-esp32/tree/master/libraries/BluetoothSerial/examples

//Bluetooth Setup debug text from the library
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

#if !defined(CONFIG_BT_SPP_ENABLED)
#error Serial Bluetooth not available or not enabled. It is only available for the ESP32 chip.
#endif

//Creation of the bluetooth object
BluetoothSerial SerialBT;

// Control Variables
int Start = 1;
int LoopDelay = 1;

// defines pins numbers
const int trigPin1 = 5;
const int echoPin1 = 18;
const int trigPin2 = 19;
const int echoPin2 = 21;
// defines variables
long duration;
int distance;

//Ints for storing wall detection
int WallFront;
int WallBack;
int WallLeft;
int WallRight;

int UltrasoundFrontThreshold = 5;
int UltrasoundRightThreshold = 10;
int UltrasoundLeftThreshold = 10;

//Array to store the IR values
int UltrasoundValues[3];

//Motor Setup
#define MotorAPWM 13  //D3
#define MotorA1 14    //D4
#define MotorA2 12    //D5
#define MotorBPWM 33  //D6
#define MotorB1 26    //D7
#define MotorB2 25    //D8
#define STBY 27       //D9

//Creation of motor controller objects for each motor
/*
Tb6612fng motor1(STBY, MotorA1, MotorA2, MotorAPWM);
Tb6612fng motor2(STBY, MotorB1, MotorB2, MotorBPWM);
*/
Tb6612fng motors(STBY, MotorA1, MotorA2, MotorAPWM, MotorB1, MotorB2, MotorBPWM);

//Variables for the rotary encoders
#define LeftOutputA 35
#define LeftOutputB 34
#define RightOutputA 2
#define RightOutputB 4

int LeftCounter = 0;
int LeftState;
int LeftLastState;

int RightCounter = 0;
int RightState;
int RightLastState;

int DistanceTravelled;

//Command Setup
String InputCommand;                //Full command inputted
int CommandIndexA;                  //Position of first colon
int CommandIndexB;                  //Position of second colon
String CurrentCommand;              //First section of the inputted string (before the first colon)
String CommandInputA;               //Second section of the inputted string (between the colons)
String CommandInputB;               //Third section of the inputted strong (after the last colon)
int CommandIntA;                    //Used if the first input is an int
int CommandIntB;                    //Used if the second input is an int
String OutputString = ("INITIAL");  //Used for data output

//Variables to declare which outputs to use. Bluetooth much cleaner than serial due to problems with ledc
int BluetoothEnabled = 1;
int SerialEnabled = 1;

int MovementCounter = 0;
char MovementList[] = {};  //Forwards = A, TurnLeft = B, TurnRight = C, Back = D

struct encoder {  //define encoder construct
  const uint8_t PIN;
  uint32_t numberRotation;
  bool triggered;
};

encoder EncoderX = { LeftOutputB, 0, false };  //create encoder instance

void IRAM_ATTR EncoderXInterrupt() {
  EncoderX.numberRotation += 1;
  EncoderX.triggered = true;
}

encoder EncoderY = { LeftOutputA, 0, false };  //create encoder instance

void IRAM_ATTR EncoderYInterrupt() {
  EncoderY.numberRotation += 1;
  EncoderY.triggered = true;
}

void setup() {
  pinMode(trigPin1, OUTPUT);  // Sets the trigPin as an Output
  pinMode(echoPin1, INPUT);   // Sets the echoPin as an Input
  pinMode(trigPin2, OUTPUT);  // Sets the trigPin as an Output
  pinMode(echoPin2, INPUT);   // Sets the echoPin as an Input

  pinMode(EncoderX.PIN, INPUT_PULLUP);
  attachInterrupt(EncoderX.PIN, EncoderXInterrupt, FALLING);

  pinMode(EncoderY.PIN, INPUT_PULLUP);
  attachInterrupt(EncoderY.PIN, EncoderYInterrupt, FALLING);

  motors.begin();                //Begins the motor object
  Serial.begin(9600);            //Serial began at a baud rate of 9600, baud rate doesnt matter particularly but must match on the terminal
  SerialBT.begin("MicroMouse");  //Bluetooth device name
  PrintMessageLn("Setup Complete");
  delay(100);
}

void loop() {
  CheckCommand();
  
  if (EncoderX.triggered) {
    Serial.println("Encoder X has triggered: ");
    Serial.println(EncoderX.numberRotation);
    EncoderX.triggered = false;
  }

  if (EncoderY.triggered) {
    Serial.println("Encoder Y has triggered: ");
    Serial.println(EncoderY.numberRotation);
    EncoderY.triggered = false;
  }
  
  delay(100);
}

//CHECKCOMMAND AND READCOMMAND ARE COMPLETELY UNNECESSARY TO THE FUNCTIONALITY OF THE DEVICE, PURELY DEBUG I DONT KNOW HOW IT WORKS AND IM TOO AFRAID TO MESS WITH IT
void CheckCommand() {  //Checks if a command has been sent to either the serial or bluetooth ports, not sure what happens if both are sent at once, please dont test it
  if (Serial.available() != 0) {
    InputCommand = Serial.readString();
    CommandIndexA = InputCommand.indexOf(":");
    if (CommandIndexA == -1) {
      InputCommand = InputCommand + ":000:";
    }
    ReadCommand();
  }
  if (SerialBT.available() != 0) {
    InputCommand = SerialBT.readString();
    CommandIndexA = InputCommand.indexOf(":");
    if (CommandIndexA == -1) {
      InputCommand = InputCommand + ":000:";
    }
    ReadCommand();
  }
}

void ReadCommand() {  //Detects the markers in the code and separates the sections, then decides which function to trigger.
  PrintMessageLn(InputCommand);
  CommandIndexA = InputCommand.indexOf(":");  //Error with detecting commands without any colons at the end
  if (CommandIndexA > -1) {
    CommandIndexB = InputCommand.indexOf(":", (CommandIndexA + 1));
    CurrentCommand = InputCommand.substring(0, CommandIndexA);
  } else {
    CurrentCommand = String(InputCommand);
    CommandIndexB = -1;
  }
  if (CommandIndexA > -1) {  //
    if (CommandIndexB > -1) {
      CommandInputA = InputCommand.substring((CommandIndexA + 1), (CommandIndexB));
      CommandInputB = InputCommand.substring((CommandIndexB + 1));
    } else {
      CommandInputA = InputCommand.substring((CommandIndexA + 1));
      CommandInputB = "0";
    }
  } else {
    CommandInputA = InputCommand.substring((CommandIndexA + 1));
    CommandInputB = "0";
  }
  Serial.println(CurrentCommand); 
  Serial.println(CommandInputA);
  Serial.println(CommandInputB);                               //Debug output
  if (CurrentCommand == "Brake" || CurrentCommand == "brake") {  //Code to decide which command has been inputted
    Brake();
  } else if (CurrentCommand == "Forwards" || CurrentCommand == "forwards" || CurrentCommand == "Forward" || CurrentCommand == "forward") {
    CommandIntA = CommandInputA.toFloat();  //Needed as by default the inputs are strings
    CommandIntB = CommandInputB.toFloat();
    Forwards(CommandIntA, CommandIntB);
  } else if (CurrentCommand == "Start" || CurrentCommand == "start") {
    Start = 1;
  } else if (CurrentCommand == "Stop" || CurrentCommand == "stop") {
    Start = 0;
  } else if (CurrentCommand == "EditLoopDelay" || CurrentCommand == "editloopdelay") {
    CommandIntA = CommandInputA.toInt();
    LoopDelay == CommandIntA;
  } else if (CurrentCommand == "Encoder" || CurrentCommand == "encoder") {
    CommandIntA = CommandInputA.toInt();  //Needed as by default the inputs are strings
    Encoder(CommandIntA);
  } else {
    PrintMessageLn("Unknown Command, did you remember the colons?");
    delay(1000);
  }
}

void PrintMessage(String Message) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (SerialEnabled == 1) {
    Serial.print(Message);
  }
  if (BluetoothEnabled == 1) {  //Doesnt print bluetooth message, only adds to buffer. Will be printed once the PrintMessageLn() command is used. Is due to library problems
    uint8_t buf[Message.length()];
    memcpy(buf, Message.c_str(), Message.length());
    SerialBT.write(buf, Message.length());
  }
}

void PrintMessageLn(String MessageLn) {  //Used to send outputs over both serial and IR, used to make other sections cleaner
  if (SerialEnabled == 1) {
    Serial.println(MessageLn);
  }
  if (BluetoothEnabled == 1) {  //Assembles the message, writes it to buffer then sends buffer
    uint8_t buf[MessageLn.length()];
    memcpy(buf, MessageLn.c_str(), MessageLn.length());
    SerialBT.write(buf, MessageLn.length());
    SerialBT.println();
  }
}


void ControlLoop() {  //Loop to control movement
}

void PollSensor() {  //Checks the sensors and adds the values to the IR storage array
  CheckUltrasonicSensor1();
  CheckUltrasonicSensor2();
  //CheckSensor3();
  LeftLastState = digitalRead(LeftOutputA);
  RightLastState = digitalRead(RightOutputA);
}

void MoveSpace(int Distance) {  //Not set up with correct values, needs to be tested, currently just set up to go based on a timer, ideally would use an encoder (code for which is below)
  PrintMessageLn("Moving Fowards");
  Forwards(0.2, -0.195);
  Encoder(Distance);
  Brake(); /*
  MovementList[MovementCounter] = 'A';
  MovementCounter = MovementCounter + 1; */
}

void TurnLeft() {

  PrintMessageLn("Turning Left");
  motors.drive(-0.2, -0.2, 490);
  delay(100);
  Brake();
  MovementList[MovementCounter] = 'B';
  MovementCounter = MovementCounter + 1;
}

void TurnRight() {

  PrintMessageLn("Turning Right");
  motors.drive(0.20, 0.2, 490);
  delay(100);
  Brake();
  MovementList[MovementCounter] = 'C';
  MovementCounter = MovementCounter + 1;
}

void TurnBack() {
  TurnLeft();
  TurnLeft();
}

void Forwards(float x, float y) {  //Command to run both motors based on the input, can be called from terminal (Forwards:x:y)
  PrintMessage("Moving Forwards, Motor speed values set to x = ");
  PrintMessage(String(x));
  PrintMessage(" y = ");
  PrintMessageLn(String(y));
  motors.drive(x, y);
}

void Brake() {  //Brake functions for both motors, can be called from terminal (Brake::)
  PrintMessageLn("Braking");
  motors.brake();
}

void CheckUltrasonicSensor1() {
  // Clears the trigPin
  digitalWrite(trigPin1, LOW);
  delayMicroseconds(2);
  // Sets the trigPin on HIGH state for 10 micro seconds
  digitalWrite(trigPin1, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin1, LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin1, HIGH);
  // Calculating the distance
  distance = duration * 0.0343 / 2;
  // Prints the distance on the Serial Monitor
  PrintMessage("Front ");
  PrintMessageLn(String(distance));
  UltrasoundValues[0] = distance;
}

void CheckUltrasonicSensor2() {
  // Clears the trigPin
  digitalWrite(trigPin2, LOW);
  delayMicroseconds(2);
  // Sets the trigPin on HIGH state for 10 micro seconds
  digitalWrite(trigPin2, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin2, LOW);
  // Reads the echoPin, returns the sound wave travel time in microseconds
  duration = pulseIn(echoPin2, HIGH);
  // Calculating the distance
  distance = duration * 0.0343 / 2;
  // Prints the distance on the Serial Monitor
  PrintMessage("Right ");
  PrintMessageLn(String(distance));
  UltrasoundValues[1] = distance;
}

void IsWallFront() {  //Checks for wall infront
  if (UltrasoundValues[0] < UltrasoundFrontThreshold) {
    WallFront = 1;
    PrintMessageLn("Wall Found Front");
  } else {
    WallFront = 0;
  }
}

void IsWallLeft() {  //Checks for wall to the left
  if (UltrasoundValues[2] < UltrasoundLeftThreshold) {
    WallLeft = 1;
    PrintMessageLn("Wall Found Left");
  } else {
    WallLeft = 0;
  }
}

void IsWallRight() {  //Checks for wall to the right
  if (UltrasoundValues[1] < UltrasoundRightThreshold) {
    WallRight = 1;
  } else {
    WallRight = 0;
  }
}

void Encoder(int TargetDistance) {  //DOESNT WORK YET
  delay(TargetDistance);
  //RUNNING INTO HARDWARE ISSUES, HALL EFFECT SENSORS WERE NOT TRIGGERING PROPERLY, LEADING TO NO DETECTED CHANGES, WORKING FROM ULTRASONIC DATA INSTEAD. LEAVING IN IN CASE WE REMOVE THE HARDWARE ISSUES
  /*
  PrintMessage("Distance Travelled: ");
  PrintMessageLn(String(DistanceTravelled));
  Forwards(10,10);
  while (DistanceTravelled < TargetDistance) {
    PrintMessageLn("In While");
    LeftState = digitalRead(LeftOutputA);  // Reads the "current" state of the outputA
    // If the previous and the current state of the outputA are different, that means a Pulse has occured
    if (LeftState != LeftLastState) {
      // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
      if (digitalRead(LeftOutputB) != LeftState) {
        LeftCounter = LeftCounter + 1;
      } else {
        LeftCounter = LeftCounter - 1;
      }
      Serial.print("Position: ");
      Serial.println(LeftCounter);
    }
    LeftLastState = LeftState;  // Updates the previous state of the outputA with the current state

    RightState = digitalRead(RightOutputA);  // Reads the "current" state of the outputA
    // If the previous and the current state of the outputA are different, that means a Pulse has occured
    if (RightState != RightLastState) {
      // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
      if (digitalRead(RightOutputB) != RightState) {
        RightCounter = RightCounter + 1;
      } else {
        RightCounter = RightCounter - 1;
      }
      Serial.print("Position: ");
      Serial.println(RightCounter);
    }
    RightLastState = RightState;  // Updates the previous state of the outputA with the current state

    DistanceTravelled = ((LeftCounter + RightCounter) / 2) * (2 * 3.14159265359 * 30);  //2*pi*wheel radius
    PrintMessageLn((String(LeftState)));
    PrintMessageLn((String(LeftLastState)));
  }
  Brake();*/
}
